# Java基础面试题

## 基础概念

### Java语言有什么特点？

Java是一门面向对象（封装、继承、多态）的编程语言。

Java具有平台无关性和移植性

Java具有稳健性

### Java是如何实现跨平台的？

Java通过JVM（Java虚拟机）来实现跨平台。

### 你认为Java的优势是什么？

我觉得可以从跨平台、垃圾回收、生态、面向对象四个方面来阐述。

- 跨平台：Java是跨平台的，不同平台执行的机器码是不一样的，而Java因为加了一层中间层JVM,所以可以做到一次编写多平台运行。即
  [Write once,Run anywhrer];编译执行过程是先把Java源代码编译成字节码，字节码再由JVM解释或JIT编译执行，而因为JIT编译时
  需要预热的，所以还提供了AOT(Ahead Of Time Complilation) ,可以直接把字节码转成机器码，来让程序重启之后能徐宿拉满战斗力。
  （解释执行比编译执行效率差）
- 垃圾回收：Java还提供了垃圾回收功能，虽说手动管理内存意味着自由、精细化地掌控，但是很容易出错；在内存较充裕的当下，将内存的
  管理交给GC来做，减轻了程序员编程的负担，提升了开发效率，更加划算！
- 生态：现在Java生态圈太全了，丰富的第三方类库、网上全面的资料、企业级框架
- 面向对象：Java是一种严格的面向对象编程语言，具有清晰的的类、对象、继承、接口等概念，支持封装、继承、多态等OOP特性，
  有助于代码的可维护性和可扩展性。

### Java和C++有什么区别？

Java和C++都是面向对象的编程语言，但是它们有以下区别：

- 平台无关性：Java是跨平台的，而C++不是。
- 内存管理：Java有自动垃圾回收机制，而C++需要手动管理内存。

### 为什么Java不支持多继承？

主要是因为多继承会产生菱形继承（也叫钻石继承）问题

```text
    A
   / \
  B   C
   \ /
    D
```

BC 继承了A,然后D继承了BC,假设D需要调用A的方法,那么就会产生二义性问题,因为BC都继承了A,所以D调用A的方法时,编译器不知道调用BC的哪一个A的方法。

此时可能会被面试官问到： 那么Java是如何解决多继承问题的呢？

Java通过接口来解决多继承问题。接口是一种抽象类型，它定义了一组方法的签名，但是没有实现。类可以实现多个接口，从而避免了多继承的问题。
为什么接口可以解决多继承问题？

因为接口只定义了方法的签名，而没有实现，所以一个类可以实现多个接口，从而避免了多继承的问题。Java8之前接口是无法定义具体方法实现的，所以即使有多个接口必须子类自己实现，所以不会发生歧义。Java8之后出了默认方法，而如果多个接口内有相同的默认方法，子类必须重写这个方法。不然，编译器就会报错。

### 面向对象和面向过程的区别？

面向对象和面向过程都是一种软件开发思想。

- 面向对象是以过程为中心的思想，它是一种基础的顺序的思维方式，面向对象方法的基础实现中也包含面向过程思想。
- 面向对象是按照人们认识客观世界的四天思维方式，采用基于对象的概念建立模型，模拟客观世界分析、设计、实现软件的办法。通过面向对象的理念使计算机软件系统能与现实世界中的系统一一对应。

### 面向对象有哪些特性？

面向对象的四大特性：封装、继承、多态、抽象

### Java中的访问修饰符有哪些？

public protected 默认 private

### 什么是Java多态性？

多态是指同一个接口或父类引用变量可以指向不同的对象实例，并根据实际指向的对象类型执行相应的方法，它允许统一方法在不同对象表现出不同的行为

多态优点：通过多态，程序可以灵活处理不同类型的对象，降低代码耦合度，增强系统的可扩展性。新增子类或实现类时，无需修改原有代码，只需通过接口或父类引用调用即可。

### 软件设计原则

- 单一职责原则：设计传教的对象，必须职责明确。
- 开闭原则：开放扩展、封闭修改。
- 里氏代换原则：子类能够完全替代父类，反之则不行。通常用于实现接口时运用。因为子类能够完全替代父类，那么这样父类就拥有很多子类，在后续的程序扩展中就很容易进行扩展，程序完全不需要进行修改即可进行扩展。
- 接口隔离原则：接口应该被小而精，不应该被大而全。一个类对另一个类的依赖应该建立在最小的接口上，而不是依赖于一个大而全的接口。
- 依赖倒置原则：高层模块不应该直接依赖于底层模块的具体实现，而应该依赖于底层的抽象。接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类
- 迪米特法则：也叫最小原则，或者说最小耦合。通常在设计程序或开发程序的时候，尽量要高内聚，低耦合。当两个类进行交互时候，会产生依赖。而迪米特法则就是这种依赖越少越好。一个对象应该尽可能少地与其他对象发生相互作用。
- 合成复用原则：尽量使用对象组合，而不是继承。

### JDK/JRE/JVM三者的关系

JRE = JVM + Java核心类库
JDK = JRE + Java工具 + 编译器 + 调试器

从JDK9开始，就不需要区分JDK和JRE了，取而代之的是模块系统（JDK被重新组织成94个模块）+ jlink工具。jlink工具可以将JDK中的模块打包成一个自定义的运行时镜像，包含了应用程序运行所需要的所有模块。并且，从JDK11开始，Oracle不再提供单独的JRE下载，JRE和JDK都包含在JDK中。

### 为什么说Java语言“编译与解释并存”？

这是因为Java语言既具有编译语言的特点，也具有解释语言的特点。Java程序先通过javac编译为字节码，再通过jvm将字节码转换成机器码执行，即解释运行和编译运行配合使用，所以可以称为混合型或者半编译型。

### Java是值传递还是引用传递？

java中不存在引用传递，只有值传递。

- 基本数据类型：传递的是值的副本，即基本类型的数值本身。因此，对方法参数的任何操作都不会影响到调用者的变量。
- 引用数据类型：传递的是引用的副本，即对象的内存地址。因此，对方法参数的操作会影响到调用者的变量。

### 谈谈你对内部类的理解

内部类分为以下几种：

- 成员内部类：定义在一个类的内部，并且不是静态的。成员内部类可以访问外部类的所有成员，包括私有成员。
- 静态内部类：定义在一个类的内部，并且是静态的。
- 局部内部类：定义在一个方法或作用域块中的类，它的作用域被限定在该方法或作用域块中。局部内部类可以访问外部类的所有成员，包括私有成员。
- 匿名内部类：没有定义名称的内部类，通常用于创建实现某个接口或继承某个类的对象。匿名内部类会在定义时立即创建对象。

### 什么是Java中的不可变类？

不可变类是指在创建后其状态（对象的字段）无法被修改的类。一旦对象被创建，它的所有属性都不能被更改，这种类的实例在整个生命周期内不变。

关键特征：

- 声明类为final,防止子类继承。
- 类的所有字段都是private和final,确保它们在初始化后不能被修改。
- 通过构造函数初始化所有字段。
- 不提供任何修改对象状态的方法（如setter方法）
- 如果类包含可变对象的引用，确保这些引用在对象外部无法被修改，例如getter方法中返回对象的副本（new一个新的对象）来保护可变对象

Java中的经典不可变类有：String Integer BigDecimal
LocalDate等

## 基础语法

### 注释有哪几种形式?

### 标识符和关键字的区别是什么?

### Java有哪些关键字？

### continue、break和return的区别是什么？

### 接口与抽象类的区别？

接口和抽象类是Java中的两种机制，用于实现类之间的继承和多态性

回答重点：

- 接口和抽象类在设计动机上有所不同。接口的设计是自上向下的。我们知晓某一行为，于是基于这些行为约束定义了接口。一些类需要有这些行为，因此实现对应的接口。抽象类的设计是自下而上的。我们写了很多类，发现它们之间有共性，有很多代码可以复用，因此将公共逻辑封装成一个抽象类，减少代码冗余。
- 所谓的自上而下 指的是先约定接口，再实现。而自下而上的 是先有一些类，才抽象了共同父类

### 说说类实例化的顺序

1. 父类的static代码块，当前类的static代码块
2. 父类的普通代码块
3. 父类的构造函数
4. 当前类的普通代码块
5. 当前类的构造函数

### 日志打印为什么不能用System.out.println()？

性能考虑：带有传参的println方法中，里面都是通过同步synchronized关键字来修改的，这说明System.out.println()其实是线程安全的。在多线程程序中，频繁的调用System.out.println()可能会导致性能问题。

### 不能使用大于小于号，如何判断两个正整数的大小？

方法一：逐次递减法

```java
public class CompareWithoutGT_LT {
  public static int compare(int a, int b) {
    // 假设a和b都是正整数
    while (a != 0 && b != 0) {
      a--;
      b--;
    }
    if (a == 0 && b == 0) {
      return 0;
    } else if (a == 0) {
      return -1; // a小于b
    } else {
      return 1; // a大于b
    }
  }
}
```

方法二：利用减法 + 判断符号位

```java
public class CompareWithoutGT_LT {
  public static int compare(int a, int b) {
    int diff = a - b;
    // 获取符号位
    // 若diff >= 0，符号位为0；若diff<0，符号位为1
    int sign = (diff >> 31) & 1; // 右移31位后取最低位

    if (diff == 0) {
      return 0;
    } else if (sign == 0) {
      return 1; // a大于b
    } else {
      return -1; // a小于b
    }

  }
}
```

## 基本数据类型

### Java的基本数据类型有哪些

### 为什么不能用浮点型表示金额？

### 如果解决浮点数运算的精度丢失问题？

### BigDecimal为什么能保证精度不丢失？

BigDecimal能够保证精度，是因为它使用了任意精度的整数表示法，而不是浮动的二进制表示。

BigDecimal内部使用两个字段存储数字，一个是整数部分intval,另一个是用来表示小数点的位置scale,避免了浮点数转化过程中可能的精度丢失计算时通过整数计算，再结合小数点位置和设置的精度与舍入行为，控制结果精度，避免了由默认浮点数舍入导致的误差。

### 超过long整型的数据应该如何表示？

在Java中，超过long整型的数据应该使用BigInteger类来表示。BigInteger类是一个用于表示任意精度的整数的类，它可以处理任意长度的整数。
相对于常规整数类型的运算来说，BigInteger运算的效率会相对较低。

### 了解包装类吗?为什么需要包装类？

Java是一种面向对象的语言，很多地方都需要使用对象而不是基本数据类型。比如集合框架中的集合类（如ArrayList、HashSet等）只能存储对象，而不能直接存储基本数据类型。为了能够在集合中存储基本数据类型，Java提供了包装类（如Integer、Double等），它们将基本数据类型封装成对象，从而可以在集合中使用。

基本数据类型位于栈上（局部变量在栈上、成员变量在堆上、静态字段在方法区），性能较高，且不支持null。它们是直接存储数值的变量，包装类是类，存储在堆中，可以用于面向对象编程，并且支持null.

为什么说是几乎所有对象实例都存在与堆中呢？还有没分配在堆上的？这是因为hotSpot虚拟机引入了JIT优化后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法内部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。

注意：基本数据类型存放在栈上是一个常见的误区！基本数据类型
的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果他们是成员变量，那么它们会存放在堆中。

### 包装类型的缓存机制了解吗？

### 自动装箱与拆箱了解吗？原理是什么？

从字节码中可以看出，装箱其实就是调用了包装类的valueOf方法，拆箱就是调用了包装类的xxxValue方法（如intValue、doubleValue等）。

### int和Integer的区别？

## 变量

### Java中的变量和常量有什么区别？

### 为什么成员变量有默认值？

### 静态变量有什么作用？

静态变量可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。

### 静态变量可能会存在什么问题

### 静态方法和变量能否被继承？

### 静态内部类与非静态内部类的区别？

### 字符型常量和字符串常量的区别？

- 形式：字符常量是单引号引起的一个字符，字符串常量是双引号引起的0个或若干个字符。

- 含义：字符常量相当于一个整型值（ASCII码值），字符串常量常常代表一个地址值（该字符串在内存中的存放位置）
- 占内存大小：字符常量占用2个字节（16位），字符串常量占用若干个字节（每个字符2个字节）

## 方法

### 静态方法为什么不能调用非静态成员？

### 静态方法和实例方法有何不同？

### 重载和重写的区别

### 构造方法有哪些特点？可以被override吗

### 构造器能被重写吗

### 如果一个类没有声明构造方法，程序能正确执行吗？

## Object

### equals和==有什么区别？

### 对象的相等和引用相等的区别？

- 对象的相等一般比较的是内存中存放的内容是否相等

- 引用相等一般比较的是它们指向的内存地址是否相等

### hashCode()方法有什么作用？

hashcode用于散列存储结构中确定对象的存储位置。可用于快速比较两个对象是否不同，因为如果它们的哈希码不同，那么它们肯定不相等。

### 2个不相等的对象的hashCode()值可能相等吗？

### 两个对象的hashCode()值相等，它们是否一定相等？

### 为什么要重写hashCode一定要重写equals方法？

### 重写equals方法时，为什么要重写hashCode方法？

### 讲讲深拷贝和浅拷贝

- 浅拷贝：创建一个新对象，但是新对象的成员变量和原对象的成员变量指向的是同一个内存地址，也就是说，新对象和原对象共享同一个成员变量。

- 深拷贝：创建一个新对象，并且新对象的成员变量和原对象的成员变量指向的是不同的内存地址，也就是说，新对象和原对象不共享任何成员变量。

### 如何实现对象克隆？

## String

### String为什么不可变？

- 不可变性：String类的成员变量value是一个final类型的字符数组，这意味着一旦String对象被创建，它的value数组就不能被改变。这就保证了String对象的不可变性。

### 为什么String要设计成不可变的？

主要有以下几点愿意：

1. 线程安全。同一个字符串实例可以被多个线程共享，因为字符串不可变，本身就是线程安全的。
2. 支持hash映射。因为String的Hash值经常会被使用，比如作为HashMap的key。如果String可变，那么Hash值就会改变，这就会导致HashMap的正常工作。不可变的特性也就使得hash值不会变，不需要重新计算。
3. 字符串常量池优化。String对象创建之后，会缓存到字符串常量池中，下次需要创建同样的对象时，可以直接返回缓存的引用。

既然我们的String是不可变的，它内部还有很多substring,replace，replaceAll这些操作的方法。这些方法好像会改变string对象？其实并不是改变了string对象，实际上每次调用replace等方法，其实会在堆内存中创建了一个新的不可变String对象

### String一定不可变吗？

不是的，String类的value数组是final类型的，但是我们可以通过反射机制来改变它的值。

### String类能被继承吗？

### 为什么JDK9要将String的底层实现由char[]改成byte[]?

主要是为了节约String占用的内存。

### Sting，StringBuffer和StringBuilder的区别

1. String是不可变的，而StringBuffer和StringBuilder是可变的。
2. StringBuffer是线程安全的，而StringBuilder不是线程安全的。
3. StringBuffer的方法都是同步的，而StringBuilder的方法都是异步的。

### String字符串使用“+”拼接的本质是什么？

“+”操作符其实就是一种语法糖，让字符串的拼接变得更简便了。可以看到编译器自动将+转换成了StringBuilder.append()方法，拼接之后再调用StringBuilder.toString()方法，返回一个新的字符串对象。

### 字符串拼接用“+”还是StringBuilder.append()方法更好？

如果拼接的字符串数量比较少，那么使用“+”操作符会更方便。因为“+”操作符是一种语法糖，不需要我们手动创建StringBuilder对象。
如果拼接的字符串数量比较多，那么使用StringBuilder.append()方法会更高效。因为每次使用“+”操作符拼接字符串，都会创建一个新的字符串对象，这会导致内存的浪费。而使用StringBuilder.append()方法，只会创建一个StringBuilder对象，然后在这个对象上进行拼接，最后调用toString()方法返回一个新的字符串对象。

### Java的StringBuilder是怎么实现的？

StringBuilder内部维护一个字符数组来存储字符序列，并用一个int count记录实际使用的字符数量

当添加新内容导致所需容量超过当前数组长度时，会自动扩容。扩容的策略是将当前数组长度翻倍，然后创建一个新的数组，将旧数组的内容复制到新数组中。

### StringJoiner是什么？

StringJoiner是Java8引入的一个类，用于拼接字符串。它可以指定分隔符、前缀和后缀，并且可以在拼接过程中添加元素。

### String类的常用方法有哪些？

- indexOf()
- lastIndexOf()
- length()
- substring()
- concat()
- replace()
- split()
- trim()
- toUpperCase()
- toLowerCase()
- equals()
- hashCode()
- toString()

### String#equals和Object#equals的区别

- String#equals方法是用来比较字符串内容是否相等的。
  String中的equals方法是被重写过的
- Object#equals方法是用来比较对象引用是否相等的。

### new String("seven")会创建几个对象？

会创建1或2个字符串对象。具体取决于字符串常量池中是否已经存在"seven"这个字符串。

- 如果字符串常量池中已经存在"seven"这个字符串，那么就只会创建一个字符串对象。
- 如果字符串常量池中不存在"seven"这个字符串，那么就会创建两个字符串对象。一个是在字符串常量池中创建的，另一个是在堆内存中创建的。

### String#intern方法有什么用？

- String#intern方法是用来将字符串添加到字符串常量池中的。
- 如果字符串常量池中已经存在了这个字符串，那么就直接返回常量池中的引用。
- 如果字符串常量池中不存在这个字符串，那么就会将这个字符串添加到常量池中，并且返回这个字符串的引用。


### String最大长度是多少？

