# Java基础面试题

## 基础概念

### Java语言有什么特点？

Java是一门面向对象（封装、继承、多态）的编程语言。

Java具有平台无关性和移植性

Java具有稳健性

### Java是如何实现跨平台的？

Java通过JVM（Java虚拟机）来实现跨平台。

### 你认为Java的优势是什么？

我觉得可以从跨平台、垃圾回收、生态、面向对象四个方面来阐述。

- 跨平台：Java是跨平台的，不同平台执行的机器码是不一样的，而Java因为加了一层中间层JVM,所以可以做到一次编写多平台运行。即
  [Write once,Run anywhrer];编译执行过程是先把Java源代码编译成字节码，字节码再由JVM解释或JIT编译执行，而因为JIT编译时
  需要预热的，所以还提供了AOT(Ahead Of Time Complilation) ,可以直接把字节码转成机器码，来让程序重启之后能徐宿拉满战斗力。
  （解释执行比编译执行效率差）
- 垃圾回收：Java还提供了垃圾回收功能，虽说手动管理内存意味着自由、精细化地掌控，但是很容易出错；在内存较充裕的当下，将内存的
  管理交给GC来做，减轻了程序员编程的负担，提升了开发效率，更加划算！
- 生态：现在Java生态圈太全了，丰富的第三方类库、网上全面的资料、企业级框架
- 面向对象：Java是一种严格的面向对象编程语言，具有清晰的的类、对象、继承、接口等概念，支持封装、继承、多态等OOP特性，
  有助于代码的可维护性和可扩展性。

### Java和C++有什么区别？

Java和C++都是面向对象的编程语言，但是它们有以下区别：

- 平台无关性：Java是跨平台的，而C++不是。
- 内存管理：Java有自动垃圾回收机制，而C++需要手动管理内存。

### 为什么Java不支持多继承？

主要是因为多继承会产生菱形继承（也叫钻石继承）问题

```text
    A
   / \
  B   C
   \ /
    D
```

BC 继承了A,然后D继承了BC,假设D需要调用A的方法,那么就会产生二义性问题,因为BC都继承了A,所以D调用A的方法时,编译器不知道调用BC的哪一个A的方法。

此时可能会被面试官问到： 那么Java是如何解决多继承问题的呢？

Java通过接口来解决多继承问题。接口是一种抽象类型，它定义了一组方法的签名，但是没有实现。类可以实现多个接口，从而避免了多继承的问题。
为什么接口可以解决多继承问题？

因为接口只定义了方法的签名，而没有实现，所以一个类可以实现多个接口，从而避免了多继承的问题。Java8之前接口是无法定义具体方法实现的，所以即使有多个接口必须子类自己实现，所以不会发生歧义。Java8之后出了默认方法，而如果多个接口内有相同的默认方法，子类必须重写这个方法。不然，编译器就会报错。

### 面向对象和面向过程的区别？

面向对象和面向过程都是一种软件开发思想。

- 面向对象是以过程为中心的思想，它是一种基础的顺序的思维方式，面向对象方法的基础实现中也包含面向过程思想。
- 面向对象是按照人们认识客观世界的四天思维方式，采用基于对象的概念建立模型，模拟客观世界分析、设计、实现软件的办法。通过面向对象的理念使计算机软件系统能与现实世界中的系统一一对应。

### 面向对象有哪些特性？

面向对象的四大特性：封装、继承、多态、抽象

### Java中的访问修饰符有哪些？

public protected 默认 private

### 什么是Java多态性？

多态是指同一个接口或父类引用变量可以指向不同的对象实例，并根据实际指向的对象类型执行相应的方法，它允许统一方法在不同对象表现出不同的行为

多态优点：通过多态，程序可以灵活处理不同类型的对象，降低代码耦合度，增强系统的可扩展性。新增子类或实现类时，无需修改原有代码，只需通过接口或父类引用调用即可。

### 软件设计原则

- 单一职责原则：设计传教的对象，必须职责明确。
- 开闭原则：开放扩展、封闭修改。
- 里氏代换原则：子类能够完全替代父类，反之则不行。通常用于实现接口时运用。因为子类能够完全替代父类，那么这样父类就拥有很多子类，在后续的程序扩展中就很容易进行扩展，程序完全不需要进行修改即可进行扩展。
- 接口隔离原则：接口应该被小而精，不应该被大而全。一个类对另一个类的依赖应该建立在最小的接口上，而不是依赖于一个大而全的接口。
- 依赖倒置原则：高层模块不应该直接依赖于底层模块的具体实现，而应该依赖于底层的抽象。接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类
- 迪米特法则：也叫最小原则，或者说最小耦合。通常在设计程序或开发程序的时候，尽量要高内聚，低耦合。当两个类进行交互时候，会产生依赖。而迪米特法则就是这种依赖越少越好。一个对象应该尽可能少地与其他对象发生相互作用。
- 合成复用原则：尽量使用对象组合，而不是继承。

### JDK/JRE/JVM三者的关系

JRE = JVM + Java核心类库
JDK = JRE + Java工具 + 编译器 + 调试器

从JDK9开始，就不需要区分JDK和JRE了，取而代之的是模块系统（JDK被重新组织成94个模块）+ jlink工具。jlink工具可以将JDK中的模块打包成一个自定义的运行时镜像，包含了应用程序运行所需要的所有模块。并且，从JDK11开始，Oracle不再提供单独的JRE下载，JRE和JDK都包含在JDK中。

### 为什么说Java语言“编译与解释并存”？

这是因为Java语言既具有编译语言的特点，也具有解释语言的特点。Java程序先通过javac编译为字节码，再通过jvm将字节码转换成机器码执行，即解释运行和编译运行配合使用，所以可以称为混合型或者半编译型。

### Java是值传递还是引用传递？

java中不存在引用传递，只有值传递。

- 基本数据类型：传递的是值的副本，即基本类型的数值本身。因此，对方法参数的任何操作都不会影响到调用者的变量。
- 引用数据类型：传递的是引用的副本，即对象的内存地址。因此，对方法参数的操作会影响到调用者的变量。

### 谈谈你对内部类的理解

内部类分为以下几种：

- 成员内部类：定义在一个类的内部，并且不是静态的。成员内部类可以访问外部类的所有成员，包括私有成员。
- 静态内部类：定义在一个类的内部，并且是静态的。
- 局部内部类：定义在一个方法或作用域块中的类，它的作用域被限定在该方法或作用域块中。局部内部类可以访问外部类的所有成员，包括私有成员。
- 匿名内部类：没有定义名称的内部类，通常用于创建实现某个接口或继承某个类的对象。匿名内部类会在定义时立即创建对象。

### 什么是Java中的不可变类？

不可变类是指在创建后其状态（对象的字段）无法被修改的类。一旦对象被创建，它的所有属性都不能被更改，这种类的实例在整个生命周期内不变。

关键特征：

- 声明类为final,防止子类继承。
- 类的所有字段都是private和final,确保它们在初始化后不能被修改。
- 通过构造函数初始化所有字段。
- 不提供任何修改对象状态的方法（如setter方法）
- 如果类包含可变对象的引用，确保这些引用在对象外部无法被修改，例如getter方法中返回对象的副本（new一个新的对象）来保护可变对象

Java中的经典不可变类有：String Integer BigDecimal
LocalDate等

## 基础语法

### 注释有哪几种形式?

### 标识符和关键字的区别是什么?

### Java有哪些关键字？

### continue、break和return的区别是什么？

### 接口与抽象类的区别？

接口和抽象类是Java中的两种机制，用于实现类之间的继承和多态性

回答重点：

- 接口和抽象类在设计动机上有所不同。接口的设计是自上向下的。我们知晓某一行为，于是基于这些行为约束定义了接口。一些类需要有这些行为，因此实现对应的接口。抽象类的设计是自下而上的。我们写了很多类，发现它们之间有共性，有很多代码可以复用，因此将公共逻辑封装成一个抽象类，减少代码冗余。
- 所谓的自上而下 指的是先约定接口，再实现。而自下而上的 是先有一些类，才抽象了共同父类

### 说说类实例化的顺序

1. 父类的static代码块，当前类的static代码块
2. 父类的普通代码块
3. 父类的构造函数
4. 当前类的普通代码块
5. 当前类的构造函数

### 日志打印为什么不能用System.out.println()？

性能考虑：带有传参的println方法中，里面都是通过同步synchronized关键字来修改的，这说明System.out.println()其实是线程安全的。在多线程程序中，频繁的调用System.out.println()可能会导致性能问题。

### 不能使用大于小于号，如何判断两个正整数的大小？

方法一：逐次递减法

```java
public class CompareWithoutGT_LT {
  public static int compare(int a, int b) {
    // 假设a和b都是正整数
    while (a != 0 && b != 0) {
      a--;
      b--;
    }
    if (a == 0 && b == 0) {
      return 0;
    } else if (a == 0) {
      return -1; // a小于b
    } else {
      return 1; // a大于b
    }
  }
}
```

方法二：利用减法 + 判断符号位

```java
public class CompareWithoutGT_LT {
  public static int compare(int a, int b) {
    int diff = a - b;
    // 获取符号位
    // 若diff >= 0，符号位为0；若diff<0，符号位为1
    int sign = (diff >> 31) & 1; // 右移31位后取最低位

    if (diff == 0) {
      return 0;
    } else if (sign == 0) {
      return 1; // a大于b
    } else {
      return -1; // a小于b
    }

  }
}
```

## 基本数据类型

### Java的基本数据类型有哪些

### 为什么不能用浮点型表示金额？

### 如果解决浮点数运算的精度丢失问题？

### BigDecimal为什么能保证精度不丢失？

BigDecimal能够保证精度，是因为它使用了任意精度的整数表示法，而不是浮动的二进制表示。

BigDecimal内部使用两个字段存储数字，一个是整数部分intval,另一个是用来表示小数点的位置scale,避免了浮点数转化过程中可能的精度丢失计算时通过整数计算，再结合小数点位置和设置的精度与舍入行为，控制结果精度，避免了由默认浮点数舍入导致的误差。

### 超过long整型的数据应该如何表示？

在Java中，超过long整型的数据应该使用BigInteger类来表示。BigInteger类是一个用于表示任意精度的整数的类，它可以处理任意长度的整数。
相对于常规整数类型的运算来说，BigInteger运算的效率会相对较低。

### 了解包装类吗?为什么需要包装类？

Java是一种面向对象的语言，很多地方都需要使用对象而不是基本数据类型。比如集合框架中的集合类（如ArrayList、HashSet等）只能存储对象，而不能直接存储基本数据类型。为了能够在集合中存储基本数据类型，Java提供了包装类（如Integer、Double等），它们将基本数据类型封装成对象，从而可以在集合中使用。

基本数据类型位于栈上（局部变量在栈上、成员变量在堆上、静态字段在方法区），性能较高，且不支持null。它们是直接存储数值的变量，包装类是类，存储在堆中，可以用于面向对象编程，并且支持null.

为什么说是几乎所有对象实例都存在与堆中呢？还有没分配在堆上的？这是因为hotSpot虚拟机引入了JIT优化后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法内部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。

注意：基本数据类型存放在栈上是一个常见的误区！基本数据类型
的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果他们是成员变量，那么它们会存放在堆中。

### 包装类型的缓存机制了解吗？

### 自动装箱与拆箱了解吗？原理是什么？

从字节码中可以看出，装箱其实就是调用了包装类的valueOf方法，拆箱就是调用了包装类的xxxValue方法（如intValue、doubleValue等）。

### int和Integer的区别？

## 变量

### Java中的变量和常量有什么区别？

### 为什么成员变量有默认值？

### 静态变量有什么作用？

静态变量可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。

### 静态变量可能会存在什么问题

### 静态方法和变量能否被继承？

### 静态内部类与非静态内部类的区别？

### 字符型常量和字符串常量的区别？

- 形式：字符常量是单引号引起的一个字符，字符串常量是双引号引起的0个或若干个字符。

- 含义：字符常量相当于一个整型值（ASCII码值），字符串常量常常代表一个地址值（该字符串在内存中的存放位置）
- 占内存大小：字符常量占用2个字节（16位），字符串常量占用若干个字节（每个字符2个字节）

## 方法

### 静态方法为什么不能调用非静态成员？

### 静态方法和实例方法有何不同？

### 重载和重写的区别

### 构造方法有哪些特点？可以被override吗

### 构造器能被重写吗

### 如果一个类没有声明构造方法，程序能正确执行吗？

## Object

### equals和==有什么区别？

### 对象的相等和引用相等的区别？

- 对象的相等一般比较的是内存中存放的内容是否相等

- 引用相等一般比较的是它们指向的内存地址是否相等

### hashCode()方法有什么作用？

hashcode用于散列存储结构中确定对象的存储位置。可用于快速比较两个对象是否不同，因为如果它们的哈希码不同，那么它们肯定不相等。

### 2个不相等的对象的hashCode()值可能相等吗？

### 两个对象的hashCode()值相等，它们是否一定相等？

### 为什么要重写hashCode一定要重写equals方法？

### 重写equals方法时，为什么要重写hashCode方法？

### 讲讲深拷贝和浅拷贝

- 浅拷贝：创建一个新对象，但是新对象的成员变量和原对象的成员变量指向的是同一个内存地址，也就是说，新对象和原对象共享同一个成员变量。

- 深拷贝：创建一个新对象，并且新对象的成员变量和原对象的成员变量指向的是不同的内存地址，也就是说，新对象和原对象不共享任何成员变量。

### 如何实现对象克隆？

## String

### String为什么不可变？

- 不可变性：String类的成员变量value是一个final类型的字符数组，这意味着一旦String对象被创建，它的value数组就不能被改变。这就保证了String对象的不可变性。

### 为什么String要设计成不可变的？

主要有以下几点愿意：

1. 线程安全。同一个字符串实例可以被多个线程共享，因为字符串不可变，本身就是线程安全的。
2. 支持hash映射。因为String的Hash值经常会被使用，比如作为HashMap的key。如果String可变，那么Hash值就会改变，这就会导致HashMap的正常工作。不可变的特性也就使得hash值不会变，不需要重新计算。
3. 字符串常量池优化。String对象创建之后，会缓存到字符串常量池中，下次需要创建同样的对象时，可以直接返回缓存的引用。

既然我们的String是不可变的，它内部还有很多substring,replace，replaceAll这些操作的方法。这些方法好像会改变string对象？其实并不是改变了string对象，实际上每次调用replace等方法，其实会在堆内存中创建了一个新的不可变String对象

### String一定不可变吗？

不是的，String类的value数组是final类型的，但是我们可以通过反射机制来改变它的值。

### String类能被继承吗？

### 为什么JDK9要将String的底层实现由char[]改成byte[]?

主要是为了节约String占用的内存。

### Sting，StringBuffer和StringBuilder的区别

1. String是不可变的，而StringBuffer和StringBuilder是可变的。
2. StringBuffer是线程安全的，而StringBuilder不是线程安全的。
3. StringBuffer的方法都是同步的，而StringBuilder的方法都是异步的。

### String字符串使用“+”拼接的本质是什么？

“+”操作符其实就是一种语法糖，让字符串的拼接变得更简便了。可以看到编译器自动将+转换成了StringBuilder.append()方法，拼接之后再调用StringBuilder.toString()方法，返回一个新的字符串对象。

### 字符串拼接用“+”还是StringBuilder.append()方法更好？

如果拼接的字符串数量比较少，那么使用“+”操作符会更方便。因为“+”操作符是一种语法糖，不需要我们手动创建StringBuilder对象。
如果拼接的字符串数量比较多，那么使用StringBuilder.append()方法会更高效。因为每次使用“+”操作符拼接字符串，都会创建一个新的字符串对象，这会导致内存的浪费。而使用StringBuilder.append()方法，只会创建一个StringBuilder对象，然后在这个对象上进行拼接，最后调用toString()方法返回一个新的字符串对象。

### Java的StringBuilder是怎么实现的？

StringBuilder内部维护一个字符数组来存储字符序列，并用一个int count记录实际使用的字符数量

当添加新内容导致所需容量超过当前数组长度时，会自动扩容。扩容的策略是将当前数组长度翻倍，然后创建一个新的数组，将旧数组的内容复制到新数组中。

### StringJoiner是什么？

StringJoiner是Java8引入的一个类，用于拼接字符串。它可以指定分隔符、前缀和后缀，并且可以在拼接过程中添加元素。

### String类的常用方法有哪些？

- indexOf()
- lastIndexOf()
- length()
- substring()
- concat()
- replace()
- split()
- trim()
- toUpperCase()
- toLowerCase()
- equals()
- hashCode()
- toString()

### String#equals和Object#equals的区别

- String#equals方法是用来比较字符串内容是否相等的。
  String中的equals方法是被重写过的
- Object#equals方法是用来比较对象引用是否相等的。

### new String("seven")会创建几个对象？

会创建1或2个字符串对象。具体取决于字符串常量池中是否已经存在"seven"这个字符串。

- 如果字符串常量池中已经存在"seven"这个字符串，那么就只会创建一个字符串对象。
- 如果字符串常量池中不存在"seven"这个字符串，那么就会创建两个字符串对象。一个是在字符串常量池中创建的，另一个是在堆内存中创建的。

### String#intern方法有什么用？

- String#intern方法是用来将字符串添加到字符串常量池中的。
- 如果字符串常量池中已经存在了这个字符串，那么就直接返回常量池中的引用。
- 如果字符串常量池中不存在这个字符串，那么就会将这个字符串添加到常量池中，并且返回这个字符串的引用。

### String最大长度是多少？

String类提供了一个length方法，返回值为int类型，而int的取值上限为2^31-1，也就是2147483647。因此，String类的最大长度为2147483647个字符。

**但是能达到这个长度的字符串值吗？**
String内部是使用一个char数组来维护字符串的，一个char类型占两个字节，如果说String最大长度是2^31-1的话，那么最大的字符串占用内存空间约等于4GB。也就是说，需要有大于4GB的JVM运行内存才行。

并且javac编译器做了限制，需要length <= 65535。
所以字符串常量在常量池中的最大长度是65535 - 1 = 65534

String在不同的状态下，具有不同的长度限制。

- 在字符串常量池中，每个字符串常量的长度不能超过65534个字符。
- 堆内存字符串的长度不超过2^31-1个字符。
- JVM内存限制

## 泛型

### 什么是泛型?有什么用？

泛型（Generics）是 Java 语言提供的一种类型安全机制，它可以在编译时检查类型错误。泛型可以提高代码的复用性、安全性和可读性。
泛型的最大好处是可以提高代码的复用性。以List接口为例，我们可以将String、Integer等类型放入List中，如不用泛型，存放String类型和Integer类型各要写一个接口，泛型可以很好的解决这个问题。

- 在编译的时候检查类型安全：泛型可以在编译时检查类型错误，比如将一个Integer对象放入一个`List<String>`中，编译器会报错。
- 避免了源代码中的许多强制类型转换，增加可读性：使用泛型可以使代码更加可读、清晰。通过泛型，可以更好地表达代码的意图，避免了使用Object等不具有明确含义的类型。
- 提高了代码的重用性；可以在不改变代码的情况下创建多个不同类型的对象，例如，使用List可以创建不同类型的列表，而不需要为每种类型编写不同的代码。

### 泛型的使用方式有哪几种？

泛型一般有三种使用方式：泛型类，泛型接口，泛型方法。

### 了解泛型擦除吗？

泛型擦除指存在于编译阶段，在进入JVM之前，与泛型相关的信息会被擦除，称之为类型擦除。

- 无限制类型擦除：当在类的定义时没有进行任何限制，那么在类型擦除后将会被替换为Object。
- 有限制类型擦除：当类定义中的参数类型存在上下限时，那么在类型擦除后，参数类型将会被替换为上限或下限。

### 知道类型擦除会造成多态的冲突吗？如何解决？

JVM的解决方法就是桥接方法。

### 项目中哪里用的了泛型？

- 自定义接口通用返回结果
- 定义Excel处理类
- 构建集合工具类

## 注解

### 什么是注解？

注解（Annotation）是 Java 语言提供的一种元数据（metadata）机制，它可以在源代码中添加一些额外的信息，这些信息不会影响程序的执行结果，但是它们可以被其他工具（如编译器、JVM、IDE 等）读取。

### 注解的解析方法有哪几种？

注解只有被解析之后才会生效

- 编译时解析：注解在编译时会被解析。
- 运行时解析：注解在运行时会被解析，通过反射机制可以获取到注解的信息。

### 注解能被继承吗?

不支持继承：不能使用关键字extends来继承某个@interface,但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口。

虽然反编译后发现注解继承了Annotation接口，但即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface

区别于注解的继承，被注解的子类继承父类注解可以用@Inherited：如果某个类使用了被@Inherited注解的注解，那么它的子类也会具有该注解。

例如

- 在依赖注入框架中，可以通过注解标记父类的组件，使其子类自动被容器识别和管理，从而减少重复配置
- ORM框架中的实体映射，父类实体可能被注解标记为可持久化，子类继承该注解后无需重新声明，简化了映射配置。

### 谈谈自定义注解的场景及实现

自定义注解是Java语言的一个强大特性，可以为代码添加元数据信息，提供额外配置或标记。它适用于多种场景。

- 配置和扩展框架：通过自定义注解，可以为框架提供配置参数或进行扩展。例如：Spring框架中的@Autowired注解，用于自动注入依赖。 @RequestMapping注解，用于映射HTTP请求。
- 运行时检查
- 规范约束

实现自定义注解的步骤如下：

1. 定义注解：使用@interface关键字定义注解，并指定注解的属性。
2. 可在注解中定义属性，并指定默认值
3. 根据需求，可添加元注解来控制注解的使用方式
4. 在代码中使用注解
5. 使用反射机制解析注解信息

通过合理运用自定义注解，可以提高代码的可s读性、可维护性和可扩展性。

## 异常

Java异常类层次结构图概览：
![alt text](./image-1.png)

### Throwable类常用方法有哪些？

- String getMessage()：返回异常发生时的简要概述。
- String toString()：返回异常的详细描述信息。
- Strubg getLocalizedMessage()：返回异常发生时的本地化概述。
- void printStackTrace()：在控制台上打印`Throwable`对象封装的异常信息。

### 常见的Exception有哪些？

常见的RuntimeException有：

- NullPointerException：空指针异常
- ArrayIndexOutOfBoundsException：数组越界异常
- IllegalArgumentException：非法参数异常
- IllegalStateException：非法状态异常
- NumberFormatException：数字格式异常
- ClassCastException：类转换异常

常见的CheckedException有：

- NoSuchFieldException：字段不存在异常
- ClassNotFoundException：类不存在异常
- IllegalAccessException：非法访问异常

### Error和Exception的区别？

在Java中，所有的异常都有一个共同的祖先`java.lang.Throwable`，它是所有异常类的根类。

- Error：错误是指在Java程序运行时发生的严重问题，通常是由于系统错误或资源不足等原因导致的。错误是不可恢复的，程序无法处理错误，只能退出。
- Exception：异常是指在Java程序运行时发生的非严重问题，通常是由于程序逻辑错误或外部环境问题等原因导致的。异常是可恢复的，程序可以通过捕获异常来处理异常情况。

### 运行时异常和非运行时异常的区别？

- 运行时异常（RuntimeException）：运行时异常是指在程序运行时发生的异常，它通常是由于程序逻辑错误或外部环境问题等原因导致的。运行时异常是可恢复的，程序可以通过捕获异常来处理异常情况。
- 非运行时异常（CheckedException）：非运行时异常是指在程序运行时发生的异常，它通常是由于程序逻辑错误或外部环境问题等原因导致的。非运行时异常是不可恢复的，程序必须处理异常情况，否则编译不通过。

### Java中的异常处理机制是怎样的？

### Java中的finally一定会被执行吗?

不一定，只有在以下情况下finally才会被执行：

- 正常执行完try块中的代码
- 发生了异常，但是异常被catch块捕获了
- 发生了异常，但是异常被finally块捕获了

如果在try块或catch块中使用了return语句，finally块中的代码也会被执行，但是finally块中的return语句会覆盖try块或catch块中的return语句。

### throw和throw的区别？

- throw：用于抛出一个异常。
- throws：用于声明一个方法可能抛出的异常类型。

### final关键字的作用？

final关键字可以用来修饰类、方法和变量。

- 修饰类：表示该类不能被继承。
- 修饰方法：表示该方法不能被重写。
- 修饰变量：表示该变量只能被赋值一次，不能被修改。

### final、finalize、finally区别？

- final：修饰类、方法、变量，表示该类、方法、变量不能被修改。
- finalize：对象被垃圾回收时，会调用该方法。
- finally：try块中的代码发生异常时，会执行finally块中的代码，然后抛出异常。

### try catch应该在for循环里面还是外面？

根据业务情况来决定

### 了解JVM的Fast Throw优化吗？

异常处理对CPU和存储都有影响

- CPU: 每次抛出异常时，JVM需要生成完整的堆栈追踪（stack trace），需遍历线程栈帧、获取方法名、类名、行号等信息、消耗CPU资源
- 异常对象本身和堆栈信息会占用堆内存，大量异常可能导致频繁GC,甚至触发OOM

因此，JVM对大量相同异常也是有优化的，当同一异常在相同位置多次抛出（约数千次），JVM会跳出堆栈生成逻辑，直接复用预分配的"空堆栈异常对象"。这种情况造成的副作用就是 高频异常的堆栈信息被隐去，日志显示`NullPointerException`等基础信息，也就无法定位具体出现异常的代码行。这个就是JVM的Fast Throw优化

如果要禁用Fast Throw优化，则在JVM启动参数中添加`-XX: -OmitStackTraceInFastThrow`,强制保留完整堆栈信息。

## 反射

### 什么是反射？

动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。
在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，并且可以获取它的任意属性。

### 反射有哪些应用场景呢？

1. 框架设计：框架设计中，通常需要使用反射技术来解耦，使框架可扩展和灵活。
2. 单元测试：在单元测试中，我们可以使用反射技术来访问私有或受保护的类成员，使测试更加全面
3. 动态代理：在动态代理中，我们可以使用反射技术来生成代理对象，从而可以在运行时期代理任意一个实现接口的对象，实现AOP功能
4. 序列与反序列化：许多Java序列化和反序列化都是基于Java反射机制来实现的，例如Java的`ObjectOutputStream`和`ObjectInputStream`

### 如何获取？

```java
// 1.通过类名.class获取
class s = SubjectService.class;
// 2.通过Class.forName()获取
class s = Class.forName("com.example.SubjectService");
// 3.通过对象.getClass()获取
SubjectService subjectService = new SubjectService();
Class s = subjectService.getClass();
// 4.通过类加载器.getClass()获取
ClassLoader classLoader = SubjectService.class.getClassLoader();
Class s = classLoader.loadClass("com.example.SubjectService");
```

比较四种获取方式的区别？

1. 类名.class:JVM将使用类装载器，将类装入内存（前提是类还没有装入内存），不做类的初始化工作，返回Class的对象
2. Class.forName()：Class.forName是一个静态方法，通过提供类的全类名，在运行时加载类。此方法还会执行类的静态初始化块。如果类名不存在或无法访问，则抛出ClassNotFoundException异常
3. 对象.getClass()：对类进行静态初始化、非静态初始化；返回引用运行时真正所指的对象（子对象的引用会赋给父对象的引用变量中）所属的类的Class对象
4. 类加载器.getClass()：ClassLoader类是一个抽象类，用于加载类的工具。每个Java类都有一个关联的类加载器，类加载器负责将字节码文件加载到JVM中。ClassLoader可以动态加载类，从不同的源加载类，如文件系统、网络、数据库等。ClassLoader类提供了loadClass()方法，用于加载类。

### 反射的优缺点？

- 优点：
  - 可以动态获取类的信息，包括类的属性、方法、构造函数等
  - 可以动态调用类的方法，包括私有方法
  - 可以动态创建类的实例
- 缺点：
  - 反射的性能较低，因为它需要在运行时动态获取类的信息
  - 反射可以破坏封装性，因为它可以访问类的私有成员

## 序列化与反序列化

### 什么是Java的序列化和反序列化？

1. 序列化：把Java对象转换成字节序列的过程称为对象的序列化
2. 反序列化：把字节序列恢复为Java对象的过程称为对象的反序列化

序列化的主要目的是实现对象的持久化存储和传输，让对象可以在不同的计算机或不同的时间点被重建和使用。通过序列化，可以将对象的状态以字节的形式保存下来，并且在需要的时候进行恢复，从而实现了对象的跨平台传输和持久化存储。

在Java中，要使一个类可以序列化，需要满足以下条件：

1. 该类必须实现Serializable接口，或者继承Serializable接口的子类
2. 所有的非静态、非瞬态的字段必须都是可序列化的

### 什么时候需要用到序列化和反序列化？

当只在本地JVM运行下Java实例，这个时候是不需要什么序列化和反序列化的。但当我们需要将内存中的对象持久化到磁盘，数据库中时，当我们需要与浏览器进行交互时，当我们需要RPC通信时，都需要用到序列化和反序列化。

**只要我们对内存中的对象进行持久化存储或传输时，就需要用到序列化和反序列化。**

1. 当需要将对象保存到文件、数据库或网络中时，需要将对象序列化为字节序列
2. 当需要从文件、数据库或网络中读取对象时，需要将字节序列反序列化为对象

### 实现序列化和反序列化为什么要实现Serializable接口呢？

在Java中实现类Serializable接口，是为了告诉JVM该类的对象是可以被序列化的。当一个类实现了Serializable接口，JVM就会知道该类的对象可以被转换为字节序列，并且可以在需要的时候将字节序列恢复为对象。

### 实现Serializable接口后，为什么还要显式指定serialVersionUID呢？

显式指定serialVersionUID，是为了避免在序列化对象时出现版本兼容性问题。在Java中，序列化对象时，JVM会根据类的结构生成一个唯一的序列化ID，这个ID会保存在类的静态字段serialVersionUID中。当类的结构发生变化时，JVM会生成一个新的序列化ID，从而导致序列化对象时出现版本兼容性问题。因此，显式指定serialVersionUID，可以避免这个问题。

### static属性为什么不会被序列化？

静态属性不会被序列化，因为静态属性属于类，而不是对象。静态属性属于类，而不是对象实例，因此静态属性的值是相同的，无论对象实例如何变化，静态属性的值都会保持不变。因此，静态属性不会被序列化，因为它们不会随对象实例一起被序列化。

### 如果有些字段不想被序列化，怎么办？

使用transient关键字修饰字段：transient关键字修饰的字段不会被序列化。

### 为什么不推荐使用JDK自带的序列化？

1. 不支持跨语言调用
2. 性能差
3. 存在安全问题

### Java创建对象的方法有哪些？

1. new关键字：通过new关键字创建对象，例如：Student s = new Student();
2. clone方法：通过clone方法创建对象，例如：Student s = (Student) obj.clone();
3. 反序列化：通过反序列化创建对象，例如：Student s = (Student) inputStream.readObject();
4. 工厂方法：通过工厂方法创建对象，例如：Student s = StudentFactory.createStudent("张三", 18);
5. 使用反射创建对象：通过反射机制创建对象，例如：Student s = (Student) Class.forName("com.geeksx.Student").newInstance();

## SPI

### 什么是SPI?

SPI即Service Provider Interface，服务提供者接口，是Java提供的一种服务发现机制，用于实现接口与实现的解耦
它允许第三方为某个接口提供实现，并通过配置文件的方式动态加载这些实现，而无需在代码中硬编码具体的实现类。
简单说：面向接口编程 + 动态加载实现类 = SPI

SPI将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现不需要修改调用方

很多框架都使用了Java的SPI机制，如JDBC、Hibernate、Spring、Dubbo等。

### SPI和API有什么区别？

1. 定义不同：SPI是服务提供者接口，用于服务的发现和加载；而API是应用程序接口，用于应用程序的调用。
2. 定位不同：SPI是在框架或库中使用的，用于服务的发现和加载；而API是在应用程序中使用的，用于应用程序的调用。
3. 作用不同：SPI的作用是将服务接口和具体的服务实现分离开来，实现解耦；而API的作用是定义应用程序的调用接口，使应用程序可以调用服务。

### JDK SPI的缺陷？

1. 无法实现按需加载
2. 缺乏IoC和AOP支持
3. 错误处理不健壮
